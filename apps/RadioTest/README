RadioBenchmark application README

1. Authors/Contacts:
   -----------------
   veresskrisztian@gmail.com (Krisztian Veress, SZTE University, Szeged, Hungary )
	
2. Description:
   ------------
   This application's main goal is to provide a universal framework that is able to 
   conduct reproducible tests/benchmarks in order to analyze and measure the radiocommunication
   generated by the applied benchmark.
   
   The focus is on the radiocommunication, hence benchmarks are given by communication
   links in a directed graph representation. For specifying benchmarks, see
   UserdefinedBenchmarks.h.
   
3. TinyOS network requirements:
   ----------------------------
   To use the framework, one needs 
    - a BaseStation mote with TOS_NODE_ID = 0.
    - multiple 'test motes' with TOS_NODE_IDs 1,2,3, ... based on the required mote count of
      the benchmark to be run
   
   One should take note that mote's channel is set to the same value (based on the DEF_CHANNEL env variable), so when using
   different radio chips, compile time definitions such as
    -DRF230_DEF_CHANNEL = $(DEF_CHANNEL), and
    -DCC2420_DEF_CHANNLE = $(DEF_CHANNEL), ...
   
   are preset in the Makefile. Of course, it is allowed to change.
   
4. Programming the motes:
   ----------------------
   To program the 'test motes', simply execute the make command with appropriate options.
   Examples:
    - iris mote connected to MIB510 programmer on the first USB slot, assign TOS_NODE_ID=1 
    UNIX   : make iris install,1 mib510,/dev/ttyUSB0
    Windows: make iris install,1 mib510,COM1
  
    - telosa/telosb motes, assign TOS_NODE_ID=2 and 3
             make telosa install,2
             make telosb install,3
    - ...
    
    4./a MAC protocol support:
         ---------------------
         The framework is able to use multiple MAC protocols whose parameters can be given by the 
         java application (ex. Low Power Listening + wakeup interval parameter)
         
         To switch between multiple MAC protocols, you must edit the relevant section in the Makefile.
         Examples:
          - use Low Power Listening:
            PFLAGS += -I./mac
            PFLAGS += -I./mac/lpl
            CFLAGS += -DLOW_POWER_LISTENING
          - use nothing:
            PFLAGS += -I./mac
            PFLAGS += -I./mac/null
            #CFLAGS += -DLOW_POWER_LISTENING
            
    4./b 32-bit statistics support:
         --------------------------
         Statistics are generally 16-bit integers. If overflows are experienced, you should consider setting
         the USE_32_BITS compile-time flag in the Makefile:
         CFLAGS += -DUSE_32_BITS
         
    4./c Defining and using benchmarks:
         ------------------------------
         To define your own benchmarks, do it in the UserdefinedBenchmarks.h file where
         additional information is available on how you can do that. After doing that, count the maximum
         of edges used in all your benchmarks, and set it in the Makefile:
         CFLAGS += -DMAX_EDGE_COUNT=8
         
         Note that by default, the Standard AND the Userdefined benchmarks are used, so specifing the 
         benchmark to be used (see README 6. section) is based on the number of benchmarks defined in
         these files (Standards come first).
         
         You can exclude any of these two by setting the EXCLUDE_STANDARD or EXCLUDE_USERDEFINED flag
         in the Makefile.
        
    4./d CC2420X support:
         ----------------
         The experimental CC2420X driver for CC2420 chips is also supported. If you want to do experiments
         with that, change the USE_CC2420X_EXPERIMENTAL variable to 'yes' in the Makefile.
         Additionally, you have to set the SZTETOSDIR env variable to point to the szte-wsn project's root
         ( szte-wsn.svn.sourceforge.net ).
         
5. Compiling the PC program:
   -------------------------
    The application comes shipped with a PC-based control program. The program depends on the
    tinyos.jar (TinyOS Java components) and libcommons-cli.jar (Apache CLI components) files, 
    so first set the CLASSPATH variable to contain at least these files, and the RadioBenchmark
    application's java source directory.
    
    Example:
      export CLASSPATH=/usr/share/java/commons-cli.jar:/opt/tinyos-2.x/support/sdk/java/tinyos.jar
      export CLASSPATH=$CLASSPATH:/path/to/RadioBenchmark/java
      
    After that, simply execute in the /path/to/RadioBenchmark/java folder:
      javac *.java
    
    In order to successfully compile, the code needs mig-generated classes, so make sure you
    have made a 'make <target>' for any target before compiling Java sources. Otherwise you 
    get errors like:
    
    Benchmark.java:235: cannot find symbol
    symbol  : variable BenchmarkStatic
    location: class Benchmark
        long period[] = new long[BenchmarkStatic.MAX_TIMER_COUNT];
         
       
    Then, executing
      java Benchmark --help
    will give you details on how this application can be used.
    
6. Using the application:
   ----------------------
   To use the application, power-on all programmed 'test-motes', plug in the BaseStation mote
   to your PC, and set the MOTECOM variable to point to the BaseStation mote.
   Examples:
    - iris BaseStation mote connected to MIB510 programmer on the first USB slot
      export MOTECOM=serial@/dev/ttyUSB1:iris
    - telosb BaseStation mote connected on the second USB slot
      export MOTECOM=serial@/dev/ttyUSB2:telosb
      
   Then, execute the following:
     java Benchmark -p 0
   which will eventually execute the 0th benchmark, and print the results on your screen. 
   For more options, see 
     java Benchmark --help
      
7. Status indicators on 'test-motes':
   ----------------------------------
   The code is written in a way so that the status of each 'test mote' can be tracked during the 
   whole process. 
    1. LED 1       on : mote is reset, standing by, waits for running a benchmark.
    2. LED 2       on : mote received configuration, waits for handshake with the PC program
    3. LED 1,LED 2 on : mote successfully configured, handshake is done
    4. LED 3       on : benchmark is currently running
    5. LED 3,LED 1 on : mote is in so-called 'lastchance' state -- being a pre-stop phase of the benchmark
    6. LED 3,LED 2 on : mote finished the benchmark, statistics are ready
    7. LED 3,LED 2 on : mote is uploading values to PC
    
   Motes should not be in states 2,3 and 5 for LONG TIME, if it happens, you can reset them by invoking
     java Benchmark -r
   ( Note that this will reset ALL motes! )
   
8. Known limitations:
   ----------------
   - Configuration and data uploading is done in a one-hop manner, so 'test-motes' must be in the radio
     reception range of the BaseStation. We plan to support multi-hop configurations and uploadings in the
     future.
   
   
   
