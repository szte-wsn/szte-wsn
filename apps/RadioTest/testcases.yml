## Test case definition file for RadioTest application
#
# Communication is modeled by a directed graph, whose edges are given here.
# A testcase is given by its 'problem' number, 'motecount' and edges.
#
# If the optional 'randomstart' value is described, motes start their test after 
# a random backoff with a maximum of 'randomstart' millisecs.
#
# If the optional 'randomseed' value is described, timers are seeded with a random
# value with a maximum of 'randomseed' millisecs.
#
# Ex:
#
#  problem: 10
#  motecount: 4
#  randomstart: 30
#  <edge list>
#
# Edges are described by their structure. Structure of one edge:
#
#  sender:   - any positive number, denoting the mote id
#            - [required]
#
#  receiver: - any positive number other than the sender, denoting the mote id,
#            - 'all', denoting all motes. This automatically implies
#              that on this edge, broadcasting is used
#            - [required]
#
#  num:      - any positive number, denoting how many messages to transmit
#            - 'inf', meaning that sender should flood the receiver with messages
#            - [optional]
#
#  trigger:  - 'timerX', -- transmitting upon timer fire event, X in [1,8]
#            - 'start', -- transmitting upon test start
#            - 'receive', -- transmitting upon reception
#            - [required]
#
#  recvfrom: - when 'receive' trigger is used, the edge number list on which the
#              'receive' trigger triggers upon message reception
#            - any positive number list, denoting the edge numbers
#            - edge numbers count from 0.
#            - 'all', denoting all edges. This case includes any broadcasts whose
#              source is other than the actual mote (sender), and any message
#              directed to the actual mote (sender) from any mote in 0->motecount
#            - [optional]
#
#  stopon:   - describes an event upon stop transmitting when num was set to 'inf'
#            - 'ack', denoting an acknowledgement, or
#            - 'timer', denoting a separate timer event
#
#
#  ack:      - force acknowledgement requests
#

##
# This file is in YAML format, keep it well-formed!
##

timer1 : { randomseed: 20, t0: 100, period: 50, isOneShot: false }

## Full-scale capabilities
problem:       113
motecount:     5
randomstart:   20
timer1 : { randomseed: 20, t0: 100, period: 50, isOneShot: false }
timer2 : { randomseed: 30, t0: 100, period: 100, isOneShot: true }

edges:
  # direct addressing
  - { sender:  4, receiver:  1, trigger: timer1 }

  # direct addressing with acks
  - { sender:  1, receiver:  5, trigger: start, ack: yes }

  # broadcast
  - { sender:  5, receiver:  all, trigger: receive, recvfrom: [1,3,4] }

  # broadcast with acks
  - { sender:  2, receiver:  all, num: 1,  trigger: timer2, ack: yes }

  # multiple messages on one event
  - { sender:  3, receiver:  5,  num: 3,   trigger: timer1 }

  # continuous message flooding on one event - never stops
  - { sender:  1, receiver:  3,  num: inf, trigger: start, ack: yes, stopon: ack }

  # multiple policies for one (sender-receiver) pair
  # WARNING: !These are treated as distinct edges!
  - { sender:  1, receiver:  2, trigger: start, ack: yes }
  - { sender:  1, receiver:  2, num: 3, trigger: receive, recvfrom: all }


  - { sender:  1, receiver:  2, num: inf, trigger: timer1, stopon: timer2 }

#########################################xx

## 0.
## 
problem:    0
motecount:  2
edges:
    - { sender:  1,  receiver:  2,  num: 1,   trigger: timer }

## 1.
##
problem:    1
motecount:  2
edges:
    - { sender:  1,  receiver:  2,  num: 1,   trigger: timer }
    - { sender:  2,  receiver:  1,  num: 1,   trigger: timer }

## 2.
##
problem:    2
motecount:  3
edges:
    - { sender:  1,  receiver:  2,  num: 1,   trigger: timer }
    - { sender:  2,  receiver:  3,  num: 1,   trigger: timer }
    - { sender:  3,  receiver:  1,  num: 1,   trigger: timer }

## 3.
##
problem:    3
motecount:  3
edges:
    - { sender:  1,  receiver:  2,  num: 1,   trigger: timer }
    - { sender:  1,  receiver:  3,  num: 1,   trigger: timer }
    - { sender:  2,  receiver:  1,  num: 1,   trigger: timer }
    - { sender:  2,  receiver:  3,  num: 1,   trigger: timer }
    - { sender:  3,  receiver:  1,  num: 1,   trigger: timer }
    - { sender:  3,  receiver:  2,  num: 1,   trigger: timer }

## 4.
##
problem:    4
motecount:  2
edges:
    - { sender:  1,  receiver:  2,  num: inf, trigger: start }


## 5.
##
problem:    5
motecount:  2
edges:
    - { sender:  1,  receiver:  2,  num: inf, trigger: start }
    - { sender:  2,  receiver:  1,  num: inf, trigger: start }

## 6.
##
problem:    6
motecount:  3
edges:
    - { sender:  1,  receiver:  2,  num: inf, trigger: start }
    - { sender:  2,  receiver:  3,  num: inf, trigger: start }
    - { sender:  3,  receiver:  1,  num: inf, trigger: start }

## 7.
##
problem:    7
motecount:  3
edges:
    - { sender:  1,  receiver:  2,  num: inf, trigger: start }
    - { sender:  1,  receiver:  3,  num: inf, trigger: start }
    - { sender:  2,  receiver:  1,  num: inf, trigger: start }
    - { sender:  2,  receiver:  3,  num: inf, trigger: start }
    - { sender:  3,  receiver:  1,  num: inf, trigger: start }
    - { sender:  3,  receiver:  2,  num: inf, trigger: start }


## 8.
##
problem:    8
motecount:  2
edges:
    - sender:    1
      receiver:  2
      policy: 
        - { num: 1, trigger: start }
        - { num: 1, trigger: receive, recvfrom: 2 }
    - { sender:  2,  receiver:  1,  num: 1,  trigger: receive, recvfrom: 1 }
    
  
## 9.
##
problem:    9
motecount:  3
edges:
    - sender:    1
      receiver:  2
      policy:
        - { num: 1, trigger: start }
        - { num: 1, trigger: receive, recvfrom: 2 }
    - { sender:  2,  receiver:  3,  num: 1,  trigger: receive, recvfrom: 1 }
    - { sender:  3,  receiver:  1,  num: 1,  trigger: receive, recvfrom: 2 }


## 10.
##
problem:    10
motecount:  3
edges:
    - sender:    1
      receiver:  2
      policy:
        - { num: 1, trigger: start }
        - { num: 1, trigger: receive, recvfrom: 2 }
    - { sender:  2,  receiver:  1,  num: 1,  trigger: receive, recvfrom: 1 }
    - sender:    1
      receiver:  3
      policy:
        - { num: 1, trigger: start }
        - { num: 1, trigger: receive, recvfrom: 3 }
    - { sender:  3,  receiver:  1,  num: 1,  trigger: receive, recvfrom: 1 }
    - sender:    2
      receiver:  3
      policy:
        - { num: 1, trigger: start }
        - { num: 1, trigger: receive, recvfrom: 3 }
    - { sender:  3,  receiver:  2,  num: 1,  trigger: receive, recvfrom: 2 }

## 11.
##
problem:    11
motecount:  4
edges:
    - { sender:  1,  receiver:  2,  num: 1, trigger: timer }
    - { sender:  2,  receiver:  3,  num: 1, trigger: receive, recvfrom: 1 }
    - { sender:  3,  receiver:  4,  num: 1, trigger: receive, recvfrom: 2 }

## 12.
##
problem:    12
motecount:  5
edges:
    - { sender:  1,  receiver:  2,  num: 1, trigger: timer }
    - { sender:  1,  receiver:  3,  num: 1, trigger: timer }
    - { sender:  2,  receiver:  4,  num: 1, trigger: receive, recvfrom: 1 }
    - { sender:  3,  receiver:  4,  num: 1, trigger: receive, recvfrom: 1 }
    - { sender:  4,  receiver:  5,  num: 1, trigger: receive, recvfrom: all }
